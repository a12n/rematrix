#!/usr/bin/env python3

import sys

def parse(f):
    def parseline(s):
        fields = s.split()
        props = dict()
        for kv in fields[1:]:
            try:
                k, v = kv.split("=")
                props[k] = v
            except ValueError:
                pass
        return (fields[0], props)
    def parsetuple(s):
        return tuple(map(int, s.split(",")))
    ans = dict()
    for line in f:
        tag, props = parseline(line)
        if tag == "info":
            ans["size"] = int(props["size"])
            ans["padding"] = parsetuple(props["padding"])
            ans["spacing"] = parsetuple(props["spacing"])
        elif tag == "common":
            ans["lineHeight"] = int(props["lineHeight"])
            ans["base"] = int(props["base"])
            ans["scaleW"] = int(props["scaleW"])
            ans["scaleH"] = int(props["scaleH"])
        elif tag == "char":
            id = int(props["id"])
            x = int(props["x"])
            y = int(props["y"])
            width = int(props["width"])
            height = int(props["height"])
            xoffset = int(props["xoffset"])
            yoffset = int(props["yoffset"])
            xadvance = int(props["xadvance"])
            ans.setdefault("chars", dict())
            ans["chars"][id] = ((x, y), (width, height), (xoffset, yoffset), xadvance)
    return ans

def write(descr, f):
    print("info size={} padding={} spacing={}".format(descr["size"], ",".join(map(str, descr["padding"])), ",".join(map(str, descr["spacing"]))), file=f)
    print("common lineHeight={} base={} scaleW={} scaleH={} pages={}".format(descr["lineHeight"], descr["base"], descr["scaleW"], descr["scaleH"], 1), file=f)
    print("page id={}".format(1), file=f)
    print("chars count={}".format(len(descr["chars"])), file=f)
    for c, ((x, y), (width, height), (xoffset, yoffset), advance) in descr["chars"].items():
        print("char id={} x={} y={} width={} height={} xoffset={} yoffset={} xadvance={} page={}".format(c, x, y, width, height, xoffset, yoffset, advance, 0))

def make_cpp_inc():
    def format(x):
        if isinstance(x, tuple) or isinstance(x, list):
            return "".join(["{", ", ".join(map(format, x)), "}"])
        else:
            return str(x)
    descr = parse(sys.stdin)
    print(format(descr["size"]), ",")
    print(format((descr["scaleW"], descr["scaleH"])), ",")
    print(format(descr["padding"]), ",")
    print(format(descr["spacing"]), ",")
    print(format(descr["lineHeight"]), ",")
    print(format(descr["base"]), ",")
    print(format(sorted(descr["chars"].items())))

# Transpose glyphs in the texture as The Matrix glyphs (all mirrored
# left/right, except 3).
def transpose_glyphs():
    from PIL import Image
    descr = parse(sys.stdin)
    img = Image.open(sys.argv[1])
    for c, ((x, y), (width, height), (xoffset, yoffset), advance) in descr["chars"].items():
        box = (x, y, x + width, y + height)
        glyph = img.crop(box)
        glyph = glyph.transpose(Image.FLIP_TOP_BOTTOM if c == ord("3") else Image.FLIP_LEFT_RIGHT)
        img.paste(glyph, box)
    img.save(sys.argv[2])

if __name__ == "__main__":
    make_cpp_inc()
